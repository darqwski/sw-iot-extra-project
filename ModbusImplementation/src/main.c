/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/

#include <stdbool.h>

#include "stm32f10x.h"
#include "stm32f1xx_nucleo.h"
#include "help_library.h"
#include "modbus.h"
#include "lcd_controller.h"
#include "Initializations.h"
#include "modbus.h"


const unsigned char GameOver [] = {
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0x3F, 0x1F, 0x0F, 0x0F,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0x0C, 0x06, 0x02, 0x42, 0x42, 0x42, 0xC2, 0xC4, 0x00,
0x00, 0x00, 0xC0, 0xF8, 0x3E, 0x06, 0x3E, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x0E, 0x78,
0xE0, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x78, 0x0E, 0xFE, 0xFE, 0x00, 0x00, 0xFE, 0xFE, 0x42, 0x42,
0x42, 0x42, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x83, 0x8F, 0x8C, 0x98, 0x90, 0x90, 0x90,
0x90, 0x9F, 0x8F, 0x80, 0x98, 0x9F, 0x87, 0x82, 0x82, 0x82, 0x82, 0x82, 0x87, 0x9F, 0x98, 0x80,
0x9F, 0x9F, 0x80, 0x80, 0x81, 0x87, 0x9C, 0x9C, 0x87, 0x81, 0x80, 0x80, 0x9F, 0x9F, 0x80, 0x80,
0x9F, 0x9F, 0x90, 0x90, 0x90, 0x90, 0x90, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0,
0xF8, 0x18, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x18, 0xF8, 0xE0, 0x00, 0x0C, 0x7C, 0xF0, 0x80, 0x00,
0x00, 0x00, 0x80, 0xF0, 0x7C, 0x0C, 0x00, 0xFC, 0xFC, 0x84, 0x84, 0x84, 0x84, 0x04, 0x00, 0x00,
0xFC, 0xFC, 0x04, 0x04, 0x04, 0x8C, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x07, 0x1F, 0x18, 0x30, 0x20, 0x20, 0x20, 0x30, 0x18, 0x1F, 0x07, 0x00, 0x00,
0x00, 0x01, 0x0F, 0x3E, 0x30, 0x3E, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x20, 0x20, 0x20,
0x20, 0x20, 0x00, 0x00, 0x3F, 0x3F, 0x01, 0x01, 0x01, 0x07, 0x1E, 0x38, 0x20, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF8,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFC,
0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};



int main(void)
{

	/******* Initializing values    **************/
	set_after_bootloader();
	 holding_register[0]= 0xAAAA;
	 write_holding_register(1,0xAAAA);
	 holding_register[2]= 0xAAAA;
	 holding_register[3]= 0xAAAA;
	 holding_register[4]= 0xAAAA;
	 holding_register[5]= 0xAAAA;
	 holding_register[6]= 0xAAAA;
	 holding_register[7]= 0xAAAA;
	 holding_register[8]= 0xAAAA;
	 holding_register[9]= 0xAAAA;

	 holding_register[10]=0xFFFF;
	 holding_register[11]=0xFFFF;
	 holding_register[12]=0xFFFF;
	 holding_register[13]=0xFFFF;
	 holding_register[14]=0xFFFF;
	 holding_register[15]=0xFFFF;
	 holding_register[16]=0xFFFF;
	 holding_register[17]=0xFFFF;
	 holding_register[18]=0xFFFF;
	 holding_register[19]=0xFFFF;

	 coils[0]=0b11111111;

	 discrete_inputs[0]= 0b11111111;


	 /******* Initializing STM32 ports    **************/
	 set_delay();
	 set_pin_out(PIN_C,PIN_8);
	 set_pin_in(PIN_C,PIN_9);
	 set_pin_out(PIN_C,PIN_6);
	 set_pin_out(PIN_B,PIN_8);
	 set_pin_in(PIN_B,PIN_9);
	 set_pin_in(PIN_C,PIN_13);
	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
	 set_ADC1();

	 set_usart2();
	 GPIO_StructInit(&gpio);

	 /* LCD PINS */
	 gpio.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_7; // SCK, MOSI
		 gpio.GPIO_Mode = GPIO_Mode_AF_PP;
		 gpio.GPIO_Speed = GPIO_Speed_50MHz;
		 GPIO_Init(GPIOA, &gpio);

		 gpio.GPIO_Pin = GPIO_Pin_6; // MISO
		 gpio.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		 GPIO_Init(GPIOA, &gpio);

		 gpio.GPIO_Pin = LCD_DC|LCD_CE|LCD_RST;
		 gpio.GPIO_Mode = GPIO_Mode_Out_PP;
		 GPIO_Init(GPIOC, &gpio);
		 GPIO_SetBits(GPIOC, LCD_CE|LCD_RST);

	 GPIO_StructInit(&gpio);
	 /* SPI init*/
	 SPI_InitTypeDef spi;
	 SPI_StructInit(&spi);
	 spi.SPI_Mode = SPI_Mode_Master;
	 spi.SPI_NSS = SPI_NSS_Soft;
	 spi.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
	 SPI_Init(SPI1, &spi);
	 SPI_Cmd(SPI1, ENABLE);

	 lcd_setup();

//	 set_ADC(PIN_A,PIN_0);
	 lcd_copy();
	 char last_furnace = 0xFF;
	 while (1) {
			/*Receiving data and saving it to bufor*/
		if (USART_GetFlagStatus(USART2, USART_FLAG_RXNE)) {					//READING BYTE FROM USART2
			read_bufor[read_bufor_length++] = USART_ReceiveData(USART2);	//READING NEXT BYTE AND MOVING BUFOR POINTER
			timer_ms = 100;
			continue;
		 }
		/*Action after 1s after last received byte*/
		 if(timer_ms == 0&&read_bufor_length!=0){
			read_modbus_request();
			send_bufor_response();
		}
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == 0){
			if(timer_ms==0)
				timer_ms=1000;
			else
				timer_ms=0;
		}
		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9) == 0){
			 input_register[2] = 0xFF;
		} else {
			 input_register[2] = 0x00;
		}
		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_9) == 0){
			 input_register[3] = 0xFF;
		} else {
			 input_register[3] = 0x00;
		}
		if(timer_ms!=0)
			 write_coil(0,1);
		else
			write_coil(0,0);

		/* DIODES ON/OFF*/
		if(get_coil(0)!=0) GPIO_SetBits(GPIOC, GPIO_Pin_6);
	 else GPIO_ResetBits(GPIOC, GPIO_Pin_6); // zgaszenie diody
	 if(get_coil(1)!=0) GPIO_SetBits(GPIOC, GPIO_Pin_9);
	 else GPIO_ResetBits(GPIOC, GPIO_Pin_9); // zgaszenie diody
	 if(get_coil(2)!=0) GPIO_SetBits(GPIOC, GPIO_Pin_8);
	 else GPIO_ResetBits(GPIOC, GPIO_Pin_8); // zgaszenie diody
	if(last_furnace != holding_register[1]){
		last_furnace = holding_register[1];
		switch(last_furnace){
			 	 case 0x00:
			 		lcd_clear();
			 		lcd_copy();
			 		 break;
			 	 case 0x01:
			 		lcd_clear();
			 		lcd_draw_bitmap(furnace_on);
			 		lcd_copy();
			 		 break;
			 	 case 0x02:
			 		lcd_clear();
			 		lcd_draw_bitmap(furnace_going);
			 		lcd_copy();
			 		 break;
			 	 case 0x03:
			 		lcd_clear();
			 		if(holding_register[2] == 1)
			 			lcd_draw_bitmap(furnace_add_1);
			 		if(holding_register[2] == 2)
			 			lcd_draw_bitmap(furnace_add_2);
			 		if(holding_register[2] == 5)
			 			lcd_draw_bitmap(furnace_add_5);
			 		lcd_copy();
			 		 break;
			 	 case 0x04:
			 		lcd_clear();
		 			lcd_draw_bitmap(furnace_error);
			 		lcd_copy();
			 		 break;

			 }
	}

	 if(get_coil(3)!=0) GPIO_SetBits(GPIOC, GPIO_Pin_5);
	 else GPIO_ResetBits(GPIOC, GPIO_Pin_5); // zgaszenie diody
	 int adc1 = adc_read(ADC_Channel_0);
	 unsigned short v1 = (unsigned short)adc1 ;
	 input_register[0] = v1;

	 int adc2 = adc_read(ADC_Channel_1);
	 unsigned short v2 = adc2 ;
	 input_register[1] = v2;

	 //	lcd_copy();

	 /*
	   GPIO_SetBits(GPIOC, GPIO_Pin_9);
		 GPIO_SetBits(GPIOC, GPIO_Pin_6);
		 GPIO_SetBits(GPIOC, GPIO_Pin_5);
		 GPIO_SetBits(GPIOC, GPIO_Pin_8);
	uint16_t adc = ADC_GetConversionValue(ADC1);
	 unsigned short v = (unsigned short)adc * 3300.0f / 4096.0f ;
	 input_register[0] = v;
	 input_register[1] = v;
	 send_bufor[0] = v >> 8;
	 send_bufor[1] = v & 0x00ff;
	 send_char(send_bufor[0]);
	 send_char(send_bufor[1]);
	 send_char('\n');
	 delay(100);

	  * */
	 }
}
